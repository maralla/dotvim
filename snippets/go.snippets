global !p
import vim
import os.path
def is_upper(arg):
	return arg and arg[0].isupper()

def add_doc(token):
	snip.rv = ''
	if is_upper(token):
		snip.rv = '// {} TODO add doc.\n'.format(token)

def get_binding_name(token):
	t = token.strip('* ')
	return t[0].lower() if t else ''
endglobal

snippet func "function" b
${1/([A-Z])?\w*/(?1:\/\/ $0 ...)/}func ${1:myFunc}(${2:args}) {
    ${VISUAL}
}
endsnippet

snippet type "type" b
`!p add_doc(t[1])
`type ${1:name} ${2:struct} {
	$0
}
endsnippet

snippet meth "bind function to struct" b
`!p add_doc(t[1])
`func (`!p snip.rv=get_binding_name(t[2])` ${6:*}${2:Type}) ${1:method}(${4:args})${5/.+/ /}${5:error} {
	$0
}
endsnippet

snippet pack "package" b
package ${1:`!v expand('%:p:h:t')`}

$0
endsnippet

snippet main "func main()" b
`!p pack = 'package main'
has_package = False
for line in vim.current.buffer:
    if line.startswith('package '):
        has_package = True
        break
if not has_package:
    snip._pack = pack + '\n\n'

snip.rv = getattr(snip, '_pack', '')
`func main() {
	$0
}
endsnippet

snippet go "goroutine" b
go func() {
	$0
}()
endsnippet

snippet const "one line const" b
const ${1:name} = ${2:value}
endsnippet

snippet co "consts" b
const (
	${1:name} = ${0:value}
)
endsnippet

snippet ctx "context.Context"
context.Context
endsnippet

snippet pln "fmt.Println" b
fmt.Println($0)
endsnippet

snippet jsonun "UnmarshalJSON" b
func (v *$1) UnmarshalJSON(data []byte) error {
	$0
}
endsnippet

snippet jsonma "MarshalJSON" b
func (v ${2:*}$1) MarshalJSON() ([]byte, error) {
    $0
}
endsnippet

snippet yamlun "UnmarshalYAML" b
func (v *$1) UnmarshalYAML(unmarshal func(interface{}) error) error {
    $0
}
endsnippet

snippet yamlma "MarshalYAML" b
func (v ${2:*}$1) MarshalYAML() (interface{}, error) {
    $0
}
endsnippet

snippet sleep "time.Sleep" b
time.Sleep($0)
endsnippet

snippet ctxtm "context.WithTimeout" b
ctx, cancel := context.WithTimeout(${1:context.Background()}, ${2:time.Second})
endsnippet

snippet ctxcancel "context.WithCancel" b
ctx, cancel := context.WithCancel(${1:context.Background()})
endsnippet

snippet bg "context.Background()" b
ctx := context.Background()
endsnippet

snippet test "test func" b
func Test${1:Name}(t *testing.T) {
	$0
}
endsnippet

snippet trun "test t.Run()" b
t.Run("${1:name}", func(t *testing.T) {
	$0
})
endsnippet

snippet terr "t.Error()" b
t.Error($1)
endsnippet

snippet err "define an error" b
err${1:Name} = errors.New("${2:bad}")
endsnippet

snippet forrange "for range loop" b
for ${1:i}, ${2:v} := range ${3:items} {
	$0
}
endsnippet

snippet for "for {}" b
for {
    $0
}
endsnippet

snippet fori "for i := 0; i < n; i++ {" b
for ${3:i} := ${4:0}; $3 < ${2:n}; $3++ {
    $1
}
endsnippet

snippet deprecate "Mark as deprecated" b
// Deprecated: ${1:Use ${2:XXX} instead}.
endsnippet

snippet wf "Write to file" b
${4:err := }ioutil.WriteFile("${1:name}", ${2:data}, ${3:0600})
endsnippet

snippet erris "error equal"
errors.Is(${3:err}, ${2:err${1:Name}})
endsnippet

snippet select "select" b
select {
case $1:
    $0
}
endsnippet

snippet bench "Benchmark" b
func Benchmark${1:Name}(b *testing.B) {
    $0
}
endsnippet

snippet eg "Example" b
func Example${1:Name}() {
    $0
}
endsnippet

snippet iferr "if err != nil" b
if ${1:err != nil} {
    $0
}
endsnippet

snippet forinc "for i := 0; i++" b
for i := 0; i < ${1:n}; i++ {
    $0
}
endsnippet

snippet ms "time.Millisecond"
time.Millisecond
endsnippet

snippet lock "mutex lock" b
${1:mutex}.Lock()
$0
$1.Unlock()
endsnippet

snippet rwlock "mutex rwlock" b
${1:mutex}.RLock()
$0
$1.RUnlock()
endsnippet

snippet deferlock "defer lock" b
${1:mutex}.Lock()
defer $1.Unlock()

$0
endsnippet

snippet deferrwlock "defer rwlock" b
${1:mutex}.RLock()
defer $1.RUnlock()

$0
endsnippet

snippet deferfunc "defer func() {" b
defer func() {
    $0
}()
endsnippet

snippet gounsafe "Not goroutine safe" b
// Not goroutine safe.
endsnippet

snippet fnonce "Must be called only once" b
// Must be called only once.
$0
endsnippet

snippet chanwait "w := make(chan struct{})" b
${2:w} := make(chan struct{})
$1
endsnippet

snippet codegen "// code gen header" b
// Code generated by $1. DO NOT EDIT.
endsnippet
